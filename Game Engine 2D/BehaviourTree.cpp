#include "BehaviourTree.hpp"
#include <algorithm>

namespace BT
{
	//BehaviourTree class
	BehaviourTree::BehaviourTree(World& world, const unsigned long int entityIndex, Node* root) : root(root), currentNode(*root), Component(world, entityIndex)
	{
		if (root == nullptr)
		{
			std::string methodName = _FUNCION_NAME_;
			std::ostringstream oss;
			oss << "The passed root node pointer was null";
			Utils::PrintDebugError(methodName, oss.str());
			throw 1;
		}
	}

	BehaviourTree::~BehaviourTree()
	{
		delete root;
	}
	
	/*
	BehaviourTree::BehaviourTree(const BehaviourTree &other) : Component<BehaviourTree>(other), context(other.context)
	{
		delete root;
		Node* newRoot = new Node(other.GetRoot());
		root = newRoot;
	}

	BehaviourTree& BehaviourTree::operator=(const BehaviourTree &other)
	{
		context = other.context;
		delete root;
		Node* newRoot = new Node(other.GetRoot());
		root = newRoot;
	}
	*/

	std::shared_ptr<void> BehaviourTree::GetContextValue(const std::string& search) const
	{
		return context.at(search);
	}

	void BehaviourTree::SetContextValue(const std::string& key, std::shared_ptr<void> value)
	{
		context.insert(std::make_pair(key, value));
	}

	Node* BehaviourTree::GetRoot() const
	{
		return root;
	}

	/*void BehaviourTree::SetRoot(Node * const root)
	{
		if (root != nullptr)
		{
			delete root;
		}
		this->root = root;
	}*/

	Node& BehaviourTree::GetCurrentNode() const
	{
		return currentNode;
	}

	void BehaviourTree::SetCurrentNode(Node& currNode)
	{
		currentNode = currNode;
	}



	// Node class
	Node::Node(Node* parent, std::vector<Node> children) :
		parent(parent), children(children), status(Status::NONE)
	{ }

	Node::~Node()
	{

	}

	Status Node::Init()
	{
		std::string methodName = _FUNCION_NAME_;
		std::ostringstream oss;
		oss << "Init method was not implemented, while you should have!";
		Utils::PrintDebugError(methodName, oss.str());
		throw 2;
	}

	Status Node::Process()
	{
		std::string methodName = _FUNCION_NAME_;
		std::ostringstream oss;
		oss << "Process method was not implemented, while you should have!";
		Utils::PrintDebugError(methodName, oss.str());
		throw 2;
	}

	Node* Node::GetParent() const
	{
		return parent;
	}

	void Node::SetParent(Node* parent)
	{
		this->parent = parent;
	}

	std::vector<Node> Node::GetChildren() const
	{
		return children;
	}

	Node& Node::GetChild(int childIndex)
	{
		return children[childIndex];
	}

	void Node::AddChild(Node& child)
	{
		children.push_back(child);
	}

	/*void Node::RemoveChild(Node& child)
	{
		children.erase(std::remove(children.begin(), children.end(), child), children.end());
	}*/

	Status Node::GetStatus() const
	{
		return status;
	}

	void Node::SetStatus(Status status)
	{
		this->status = status;
	}
}



/*
 *    THEORY:
 * How to call copy constructor in derived class when the base class doesn't have default constructor?
 * Call the default copy constructor of the base class generated by the compiler.
 */